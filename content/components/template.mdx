# Template Files (.template)

TypeComposer provides a powerful **`.template`** file system that allows you to write component templates using **TSX syntax** in separate files, keeping your UI markup clean and organized.

Template files are automatically linked to their corresponding TypeScript component files and injected into the `template()` method at build time.

---

## 1. Overview

### What are Template Files?

Template files (`.template`) are dedicated files for component UI markup that:
- Use full **TSX syntax** with IntelliSense support
- Allow **imports** of other components and utilities
- Are automatically linked to component classes by name
- Get injected into the component's `template()` method
- **Cannot** contain variable declarations (only TSX elements)

### File Naming Convention

Template files must match the name of their corresponding component file:

```
src/
  pages/
    AppPage.ts          ‚Üê Component class file
    AppPage.template    ‚Üê Template file (auto-linked)
```

**Supported patterns:**
- `ComponentName.ts` ‚Üí `ComponentName.template`
- `ComponentName.tsx` ‚Üí `ComponentName.template`

---

## 2. Basic Usage

### Traditional Template Method

In standard TypeComposer components, you define templates using the `template()` method:

```typescript
import { Component } from 'typecomposer';
import { NavBar } from '@/components/NavBar';

export class AppPage extends Component {
  template() {
    return (
      <div>
        <NavBar />
        <h1>Welcome</h1>
      </div>
    );
  }
}
```

### Using a .template File

Instead, you can separate the template into a dedicated file:

**AppPage.ts**
```typescript
import { Component } from 'typecomposer';

export class AppPage extends Component {
  // No template() method needed - it will be auto-injected
}
```

**AppPage.template**
```tsx
import { NavBar } from '@/components/NavBar';

<div>
  <NavBar />
  <h1>Welcome</h1>
</div>
```

TypeComposer automatically injects the `.template` content into the `template()` method at build time.

---

## 3. Template File Rules

### ‚úÖ What You CAN Do

**1. Import Components and Utilities**

```tsx
import { NavBar } from '@/components/NavBar';
import { Button } from '@/components/Button';
import { formatDate } from '@/utils/date';

<div>
  <NavBar />
  <Button onClick={this.handleClick}>Click me</Button>
</div>
```

**2. Use TSX Elements and Fragments**

```tsx
<>
  <div className="header">
    <h1>Title</h1>
  </div>
  <div className="content">
    <p>Content here</p>
  </div>
</>
```

**3. Use Component Properties and Methods**

```tsx
<div>
  <h1>{this.title.value}</h1>
  <button onClick={this.handleClick}>Click</button>
  <p style={{ color: this.textColor }}>Dynamic styling</p>
</div>
```

**4. Use Expressions and Conditionals**

```tsx
<div>
  <h1>{this.isLoggedIn ? 'Welcome back!' : 'Please login'}</h1>
  <ul>
    {this.items.map(item => <li key={item.id}>{item.name}</li>)}
  </ul>
</div>
```

### ‚ùå What You CANNOT Do

**1. Variable Declarations**

```tsx
// ‚ùå NOT ALLOWED
const title = "My Title";
let count = 0;

<div>{title}</div>
```

**2. Function Declarations**

```tsx
// ‚ùå NOT ALLOWED
function formatText(text: string) {
  return text.toUpperCase();
}

<div>{formatText(this.text)}</div>
```

**3. Class Declarations**

```tsx
// ‚ùå NOT ALLOWED
class Helper {
  format(text: string) {
    return text;
  }
}
```

**Why?** Template files are designed to contain **only UI markup**. All logic, state, and helper functions should be defined in the component class (`.ts` or `.tsx` file).

---

## 4. Complete Example

### Component File (AppPage.ts)

```typescript
import { Component, ref } from 'typecomposer';

export class AppPage extends Component {
  // State
  title = ref('My Application');
  count = ref(0);

  // Methods
  increment() {
    this.count.value++;
  }

  decrement() {
    this.count.value--;
  }

  // No template() method - defined in .template file
}
```

### Template File (AppPage.template)

```tsx
import { NavBar } from '@/components/NavBar';
import { Button } from '@/components/Button';

<div className="app-page">
  <NavBar title={this.title.value} />
  
  <main>
    <h1>{this.title.value}</h1>
    
    <div className="counter">
      <Button onClick={this.decrement}>-</Button>
      <span>{this.count.value}</span>
      <Button onClick={this.increment}>+</Button>
    </div>
  </main>
</div>
```

---

## 5. VS Code Extension Support

### Installation

To enable **syntax highlighting**, **IntelliSense**, and **type checking** for `.template` files, install the official VS Code extension:

**Extension:** `TypeComposer Template Language Support`  
**Marketplace:** <a href="https://marketplace.visualstudio.com/items?itemName=typecomposer-language-support.typecomposer-template" target="_blank" rel="noopener noreferrer">TypeComposer Template Language Support ‚Üí</a>

### How to Install

You can install the extension in one of two ways:

#### Option 1 ‚Äî From VS Code
1. Open the **Extensions** view (`Ctrl`/`Cmd` + `Shift` + `X`)
2. Search for **"TypeComposer"**
3. Click **Install** on the *TypeComposer Template Language Support* extension

#### Option 2 ‚Äî From the Web
Go directly to the <a href="https://marketplace.visualstudio.com/items?itemName=typecomposer-language-support.typecomposer-template" target="_blank" rel="noopener noreferrer">VS Code Marketplace page</a> and click **Install**.

### Features

The extension provides:
- ‚úÖ **TSX syntax highlighting** in `.template` files
- ‚úÖ **IntelliSense** for component props and methods
- ‚úÖ **Auto-completion** for imports and components
- ‚úÖ **Type checking** and error detection
- ‚úÖ **Go to Definition** for imported components
- ‚úÖ **Auto-closing tags** and snippets

---

## 6. Lifecycle Integration

### When Templates Are Executed

The `template()` method (whether defined manually or from a `.template` file) is executed by TypeComposer **before** the `onCreate()` lifecycle hook.

**Execution Order:**
1. `constructor()`
2. `onInit()`
3. **`template()`** ‚Üê Template rendered here
4. `onCreate()`
5. `onConnected()`

### Accessing Component State

You can safely access component properties in templates because they are initialized before the template executes:

```typescript
// AppPage.ts
export class AppPage extends Component {
  title = ref('Hello'); // ‚úÖ Available in template

  constructor() {
    super();
    this.count = ref(0); // ‚úÖ Also available
  }
}
```

```tsx
// AppPage.template
<div>
  <h1>{this.title.value}</h1>
  <p>Count: {this.count.value}</p>
</div>
```

---

## 7. Best Practices

### ‚úÖ DO

**Keep Templates Pure and Declarative**
```tsx
// ‚úÖ Good - declarative markup
<div className="user-card">
  <h2>{this.user.name}</h2>
  <p>{this.user.email}</p>
</div>
```

**Use Component Methods for Logic**
```typescript
// Component file
formatDate(date: Date): string {
  return date.toLocaleDateString();
}
```

```tsx
// Template file
<span>{this.formatDate(this.createdAt)}</span>
```

**Import Reusable Components**
```tsx
import { Card } from '@/components/Card';
import { Avatar } from '@/components/Avatar';

<Card>
  <Avatar src={this.user.avatar} />
</Card>
```

### ‚ùå DON'T

**Don't Inline Complex Logic**
```tsx
// ‚ùå Bad - complex logic in template
<div>
  {this.items.filter(x => x.active).map(x => x.value.toUpperCase()).join(', ')}
</div>

// ‚úÖ Better - extract to computed property
<div>{this.activeItemNames}</div>
```

**Don't Declare Variables**
```tsx
// ‚ùå Not allowed
const formattedDate = new Date().toLocaleDateString();
<span>{formattedDate}</span>
```

---

## 8. Advanced Patterns

### Conditional Rendering

```tsx
<div>
  {this.isLoading ? (
    <div className="spinner">Loading...</div>
  ) : (
    <div className="content">
      {this.data.map(item => (
        <div key={item.id}>{item.name}</div>
      ))}
    </div>
  )}
</div>
```

### Component Composition

```tsx
import { Header } from '@/components/Header';
import { Sidebar } from '@/components/Sidebar';
import { Footer } from '@/components/Footer';

<div className="app-layout">
  <Header user={this.currentUser} />
  
  <div className="app-body">
    <Sidebar items={this.menuItems} />
    <main>{this.children}</main>
  </div>
  
  <Footer />
</div>
```

### Event Handlers

```tsx
<form onSubmit={this.handleSubmit}>
  <input
    type="text"
    value={this.username.value}
    onInput={(e) => this.username.value = e.target.value}
  />
  <button type="submit">Submit</button>
</form>
```

---

## 9. Migration from Inline Templates

If you have existing components with inline `template()` methods, migration is simple:

**Before:**
```typescript
// AppPage.ts
export class AppPage extends Component {
  template() {
    return (
      <div>
        <h1>Hello</h1>
      </div>
    );
  }
}
```

**After:**

**AppPage.ts**
```typescript
export class AppPage extends Component {
  // Remove template() method
}
```

**AppPage.template** (new file)
```tsx
<div>
  <h1>Hello</h1>
</div>
```

---

## 10. Troubleshooting

### Template Not Found Error

**Error:** `No corresponding .ts or .tsx file found for this .template file`

**Solution:** Ensure the `.template` file name exactly matches the component class file:
- `AppPage.template` ‚Üí `AppPage.ts` ‚úÖ
- `appPage.template` ‚Üí `AppPage.ts` ‚ùå (case mismatch)

### Type Errors in Template

**Problem:** VSCode shows type errors in `.template` file

**Solution:**
1. Install the TypeComposer VSCode extension
2. Ensure your `tsconfig.json` includes the component directory
3. Check that imports are correct

### Syntax Errors

**Error:** `The file contains non-JSX/TSX code after imports`

**Solution:** Remove any variable declarations, function declarations, or other non-TSX code. Only imports and JSX elements are allowed.

---

## 11. Summary

| Feature | Description |
|---------|-------------|
| **File Extension** | `.template` |
| **Syntax** | Full TSX/JSX support |
| **Imports** | ‚úÖ Allowed |
| **Variables** | ‚ùå Not allowed |
| **Execution Time** | Before `onCreate()` |
| **Auto-linking** | By matching file name |
| **VSCode Support** | Install TypeComposer extension |

### Key Benefits

- üìù **Separation of Concerns**: Keep UI markup separate from logic
- üé® **Better Syntax Highlighting**: Full TSX support in dedicated files
- üîç **Type Safety**: Full IntelliSense and type checking
- üîÑ **Hot Reload**: Changes reflect immediately in development
- üßπ **Cleaner Code**: Component class files focus on logic and state

---

## 12. Conclusion

Template files are a powerful feature in TypeComposer that improves code organization and developer experience. By separating UI markup from component logic, your codebase becomes more maintainable and easier to navigate.

**Remember:**
- Template files must match component file names
- Use TypeScript/TSX syntax with full IntelliSense
- Keep templates declarative (no variable/function declarations)
- Install the VSCode extension for the best experience
- Templates execute before `onCreate()`

---

> üí° **Pro Tip:** Use `.template` files for complex component UIs and inline `template()` methods for simple, single-element components.
