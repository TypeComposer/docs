# Why TypeComposer?

TypeComposer simplifies UI and web app development with a declarative, class-based approach — where logic, state, and rendering live together in familiar TypeScript classes.


## Why no HTML templates?

Everything in one place — no split between `.ts` and `.html`.
Instead of template DSLs, TypeComposer keeps rendering in your class:

```ts
import { DivElement, ButtonElement } from "typecomposer";

new DivElement({
  children: [
    new ButtonElement({ text: "Increment", onclick: () => counter.value++ }),
    new DivElement({ children: [`Counter: ${counter.value}`] }),
  ],
});
```

* **Encapsulation**: props, state, methods, and render all live here.
* **Dynamic flexibility**: loops, conditionals, transforms done with code, not DSLs.
* **No mismatch**: one language (TypeScript), no syncing template logic.

## Why TypeScript native?

Type safety, inference, and tooling just work because everything is TypeScript.

```ts
import { DivElement, ButtonElement } from "typecomposer";

const btn = new ButtonElement({ text: "Click me" });
btn.onclick = () => console.log("Button clicked");

```

* **Type safety end-to-end**: props, state, and render are strongly typed.
* **Tooling friendly**: IDEs, linters, refactors work with zero extra setup.
* **Generics & inference**: reusable, expressive APIs without boilerplate.
* **Zero impedance mismatch**: no need to map template bindings to TS.

## Why React friendly?

You don’t have to choose — TypeComposer interoperates with React:

```ts
import { DivElement } from "typecomposer";

const greeting = new DivElement({ children: ["Hello, Alice!"] });

// Can be wrapped or used in React
<SomeReactWrapper>{greeting}</SomeReactWrapper>
```

* **Familiar model**: React-style components, but TypeScript-first.
* **Ecosystem leverage**: reuse React libraries and patterns.
* **Progressive adoption**: migrate piece by piece, not all at once.

## Lightning fast

Minimal runtime, optimized output. Most work is resolved at build time.

* **Optimized bundling**: fast startup, efficient HMR.
* **Minimal runtime abstractions**: fewer layers of indirection.
* **Fine-grained updates**: only what changed re-renders.
