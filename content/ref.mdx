# Overview

In TypeComposer, `ref` is a reactive reference system used to track and manage state. It wraps primitive values, objects, and collections, allowing automatic updates in dependent components when the value changes.

## 1. Key Features

- Supports primitive values (`string`, `number`, `boolean`).
- Supports complex types such as `Array`, `Map`, `Set`, and objects.
- Automatically tracks dependencies and triggers updates.
- Provides `subscribe()` and `unsubscribe()` methods for reactivity.
- Supports computed values with `computed()`.

## 2. Creating a Ref

A `ref` can be created using the `ref()` function. The provided value is wrapped in a reactive reference that can be accessed via `.value`.

## 3. Example Usage

```javascript
import { ref } from "typecomposer";

const count = ref(0);
console.log(count.value); // 0

count.value = 5;
console.log(count.value); // 5
```

## 4. Reactive Data Types

| Type | Ref Type | Description | Example |
|------|----------|-------------|---------|
| string | RefString | Reactive string reference. | `const name = ref("hello")` |
| number | RefNumber | Reactive number reference. | `const count = ref(0)` |
| boolean | RefBoolean | Reactive boolean reference. | `const active = ref(true)` |
| Array&lt;T&gt; | RefList&lt;T&gt; | Reactive array reference. | `const items = ref(["a", "b"])` |
| Map&lt;K, V&gt; | RefMap&lt;K, V&gt; | Reactive map reference. | `const map = ref(new Map())` |
| Set&lt;T&gt; | RefSet&lt;T&gt; | Reactive set reference. | `const set = ref(new Set())` |
| Object | RefObject&lt;T&gt; | Reactive object reference. | `const obj = ref({ key: "value" })` |

## 5. Example with Reactive Objects

```javascript
const data = ref({
  history: "hash",
  ob: { tes: "test" }
});

console.log(data.value.history); // "hash"
data.value.history = "history";
console.log(data.value.history); // "history"
```

## 6. Using Ref as a List

Refs can also be used to manage reactive lists. The `.value` property is still required when modifying the array.

```javascript
const l = ref(["a", "b"]);

// Adding a new element to the list
l.value.push("c");

console.log(l.value); // ["a", "b", "c"]
```

## 7. Computed Properties

The `computed()` function allows creating reactive derived values based on existing refs.

```javascript
import { computed, ref } from "typecomposer";

const num = ref(5);
const squared = computed(() => num.value * num.value, [num]);

console.log(squared.value); // 25

num.value = 10;
console.log(squared.value); // 100
```

## 8. Subscribing to Changes

Refs support subscriptions to reactively track changes.

```javascript
const count = ref(0);

count.subscribe((newValue) => {
  console.log("Updated:", newValue);
});

count.value = 10; // Logs: "Updated: 10"
```

## 9. Unsubscribing from Changes

```javascript
const name = ref("Alice");

const logName = (value) => {
  console.log("Name changed to:", value);
}

name.subscribe(logName);
name.value = "Bob"; // Logs: "Name changed to: Bob"

name.unsubscribe(logName);
name.value = "Charlie"; // No log output
```

## 10. Default Behavior

- `ref` wraps a value and makes it reactive.
- `.value` must be used to access or modify the wrapped value.
- Changes in a `ref` trigger updates to subscribed functions or components.

## 11. When to Use `ref`

- When managing reactive state in components.
- When tracking changes to primitive values, objects, or collections.
- When computing derived values that should update reactively.

## Conclusion

The `ref` system in TypeComposer provides a simple and efficient way to manage reactivity. With support for primitive and complex data structures, `ref` enables seamless state management and automatic updates across components.
